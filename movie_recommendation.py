# -*- coding: utf-8 -*-
"""movie_recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Sw5PW-JVlSVK0B1wdCVfaAHnFNdoRJOK

<!-- image from image -->
![image](images/exemple.png)
"""

import sys
from pathlib import Path
import pandas as pd
import numpy as np
from graphdatascience import GraphDataScience

"""connect to Neo4j database and test"""

# Neo4j connection details
DB_ULR = 'bolt://localhost:7687'
DB_USER = 'neo4j'
DB_PASS = 'test1234'
gds = GraphDataScience(DB_ULR, auth=(DB_USER, DB_PASS))
gds.version()

"""Test"""

nodes = gds.run_cypher(
    '''
    MATCH (n)
    RETURN COUNT(n)
    '''
)
nodes.head()

"""Load data from MovieLens"""

movies = pd.read_csv('ml-1m/movies.dat',sep='::',encoding = 'ISO-8859-1', names = ['MovieID','Title','Genres'])
ratings = pd.read_csv('ml-1m/ratings.dat',sep='::',encoding = 'ISO-8859-1', names = ['UserID','MovieID','Rating','Timestamp'])
users = pd.read_csv('ml-1m/users.dat',sep='::',encoding = 'ISO-8859-1', names = ['UserID','Gender','Age','Occupation','Zip_code'])

display(movies.head())
display(ratings.head())
display(users.head())

"""Insert data to graph DB"""

# create user nodes
def create_user_nodes():
    """
    Crée les nœuds User dans la base de données Neo4j à partir du DataFrame users.
    Retourne :
        pd.DataFrame : Résultat de la requête de création.
    """
    gds.run_cypher('create constraint if not exists for (n:User) require (n.id) is node key')
    create_customer_res = gds.run_cypher(
        '''
            unwind $data as row
            merge (n:User{id: row.UserID})
            set n.Gender = row.Gender
            set n.Age = row.Age
            return count(*) as custmers_created
        ''', params={'data': users.to_dict('records')}
    )
    return create_customer_res

create_customer_res = create_user_nodes()
create_customer_res.head()

# create movies nodes
def create_movie_nodes():
    """
    Crée les nœuds Movie dans la base de données Neo4j à partir du DataFrame movies.
    Retourne :
        pd.DataFrame : Résultat de la requête de création.
    """
    gds.run_cypher('create constraint if not exists for (n:Movie) require (n.id) is node key')
    create_movie_res = gds.run_cypher(
        '''
            unwind $data as row
            merge (n:Movie{id: row.MovieID})
            set n.Title = row.Title
            set n.Genres = row.Genres
            return count(*) as movies_created
        ''', params={'data': movies.to_dict('records')}
    )
    return create_movie_res

create_movie_res = create_movie_nodes()
create_movie_res.head()

# create ratings relationship
def create_rating_relationship():
    """
    Crée les relations RATED entre les nœuds User et Movie dans la base de données Neo4j à partir du DataFrame ratings.
    Retourne :
        pd.DataFrame : Résultat de la requête de création.
    """
    i = 1
    for chunk in np.array_split(ratings, 200):
        if i%10 == 0:
            print(i)
        create_rated = gds.run_cypher(
        '''
            unwind $data as row
            match (u:User{id:row.UserID}) , (n:Movie{id:row.MovieID})
            merge (u)-[r:RATED]->(n)
            set r.Rating = row.Rating
            return count(*) as create_rated
        ''',params = {'data':chunk.to_dict('records')}
    )
        i = i+1
    create_rated.head()

create_rating_relationship()

"""<!-- image from image -->
![image](images/view_relation.png)
"""

# CALL apoc.meta.schema()
# CALL .schema.visualization()

"""****Recommandation****
Recommandation of similar movie
A simple way to find similar movie for specific is to count how many paths of the from
(movie1)-[]->(user)-[]->(movie2)
where movie1 is the movie we want to find similar movie for
we order the movie2 based on the number of path that connect the two movie. The idea is that movie will receive
excellente rating by the same user
"""

def find_similar_movies(title, rating=5, top_n=10):
    """
    Trouve les films similaires à un titre donné selon les utilisateurs ayant donné une note spécifique.
    Args:
        title (str): Le titre du film à rechercher.
        rating (int): La note à considérer pour la similarité (par défaut : 5).
        top_n (int): Nombre de résultats à retourner (par défaut : 10).
    Returns:
        pd.DataFrame: DataFrame des films similaires.
    """
    query = '''
        MATCH (n1:Movie)-[r1]-(u:User)-[r2]-(n2:Movie)
        WHERE n1.Title CONTAINS $title
            AND n2.Title<>$title
            AND r1.Rating = $rating AND r2.Rating = $rating
        RETURN n2.Title, n2.Genres, count(DISTINCT(u)) as common_users
        ORDER BY common_users DESC
    '''
    result = gds.run_cypher(query, params={'title': title, 'rating': rating})
    return result.head(top_n)

"""AND PARAMETRIC QUERY"""

# check the similar movies
def find_similar_movies(title, rating=5, top_n=10):
    """
    Trouve les films similaires à un titre donné selon les utilisateurs ayant donné une note spécifique.
    Args:
        title (str): Le titre du film à rechercher.
        rating (int): La note à considérer pour la similarité (par défaut : 5).
        top_n (int): Nombre de résultats à retourner (par défaut : 10).
    Returns:
        pd.DataFrame: DataFrame des films similaires.
    """
    query = '''
        MATCH (n1:Movie)-[r1]-(u:User)-[r2]-(n2:Movie)
        WHERE n1.Title CONTAINS $title
            AND n2.Title<>$title
            AND r1.Rating = $rating AND r2.Rating = $rating
        RETURN n2.Title, n2.Genres, count(DISTINCT(u)) as common_users
        ORDER BY common_users DESC
    '''
    result = gds.run_cypher(query, params={'title': title, 'rating': rating})
    return result.head(top_n)

similar_movies = find_similar_movies('Toy Story (1995)', rating=5, top_n=10)
similar_movies

"""Use base of recommandatio n"""

gds.run_cypher("CALL gds.graph.drop('myGraph', false)")

# create a projection
create_projection = gds.run_cypher(
    '''
        CALL gds.graph.project(
            'myGraph',
            ['User', 'Movie'],
            {
                RATED: {
                    properties: 'Rating'
                }
            }
        );
    ''')

create_projection.head()

def get_user_similarity(graph_name='myGraph', top_n=10):
    """
    Calcule la similarité entre utilisateurs à partir du graphe projeté.
    Args:
        graph_name (str): Nom du graphe projeté dans Neo4j.
        top_n (int): Nombre de lignes à retourner (par défaut 10).
    Returns:
        pd.DataFrame: DataFrame des similarités utilisateur-utilisateur.
    """
    user_similarity = gds.run_cypher(
        f'''
        CALL gds.nodeSimilarity.stream('{graph_name}')
        YIELD node1, node2, similarity
        RETURN gds.util.asNode(node1).id AS UserID1,
               gds.util.asNode(node2).id AS UserID2,
               similarity
        ORDER BY similarity DESC, UserID1,  UserID2
        '''
    )
    return user_similarity.head(top_n)

user_similarity = get_user_similarity(top_n=10)
user_similarity

# create similar relationship
i = 1
for chunk in np.array_split(user_similarity.query('UserID1 > UserID2'), 10):
    if i%10 == 0:
        print(i)
    create_rated = gds.run_cypher(
        '''
            unwind $data as row
            match (u1:User{id:row.UserID1}) , (u2:User{id:row.UserID2})
            merge (u1)-[r:SIMILAR]->(u2)
            set r.similarity = row.similarity
            return count(*) as create_rated
        ''',params = {'data':chunk.to_dict('records')}
    )
    i = i+1
create_rated.head()

# check the similar movies
def recommend_movies_for_user(user_id, top_n=31):
    """
    Recommande des films pour un utilisateur en se basant sur les notes des utilisateurs similaires.
    Args:
        user_id (int): L'identifiant de l'utilisateur pour lequel recommander des films.
        top_n (int): Nombre de recommandations à retourner.
    Returns:
        pd.DataFrame: DataFrame des films recommandés.
    """
    query = '''
        MATCH (u1:User)-[r1:SIMILAR]-(u2)-[r2:RATED]-(m:Movie)
        WHERE id(u1) = $id
           AND NOT ((u1)-[]-(m))
        RETURN m.Title, m.Genres, Sum(r1.similarity * r2.Rating) / Sum(r1.similarity)+ log(count(r2)) as score
        ORDER BY score DESC
    '''
    result = gds.run_cypher(query, params={'id': user_id})
    return result.head(top_n)

similar_movies_for_user = recommend_movies_for_user(4725, top_n=31)
similar_movies_for_user

# cherk actual movies
def get_actual_movies_for_user(user_id, top_n=10):
    """
    Récupère les films réellement notés par un utilisateur, triés par note décroissante.
    Args:
        user_id (int): L'identifiant de l'utilisateur.
        top_n (int): Nombre de films les mieux notés à retourner.
    Returns:
        pd.DataFrame: DataFrame des films notés par l'utilisateur.
    """
    result = gds.run_cypher(
        '''
        MATCH (u1:User)-[r:RATED]-(m:Movie)
        WHERE id(u1) = $id
        RETURN m.Title, m.Genres, r.Rating as rating
        ORDER BY rating DESC
        ''', params={'id': user_id}
    )
    return result.head(top_n)

actual_movies = get_actual_movies_for_user(4725, top_n=15)
actual_movies

"""***Recommendation par rapport au genre***

  Recommande des films à un utilisateur basé sur ses genres préférés.

    Params :
    - user_id : ID de l'utilisateur dans Neo4j.
    - gds : Instance GDS connectée.
    - top_genres : nombre de genres favoris à considérer.
    - top_recommendations : nombre de films recommandés à retourner.

    Retour :
    - DataFrame des recommandations.
    '''
"""

def recommend_by_genre(user_id, top_genres=3, top_recommendations=10):
    """
    Recommande des films à un utilisateur en se basant sur les genres des films qu'il a notés positivement.
    Args:
        user_id (int): L'identifiant de l'utilisateur pour lequel recommander des films.
        top_genres (int): Nombre de genres à considérer pour la recommandation.
        top_recommendations (int): Nombre de recommandations à retourner.
        Returns:
        pd.DataFrame: DataFrame des films recommandés.
    """
    query = f"""
    MATCH (u:User {{id: $id}})-[r:RATED]->(m:Movie)
    WHERE r.Rating >= 4
    WITH u, split(m.Genres, '|') AS genres
    UNWIND genres AS genre
    WITH u, genre, count(*) AS genreScore
    ORDER BY genreScore DESC
    WITH u, collect(genre)[..{top_genres}] AS topGenres

    MATCH (rec:Movie)
    WHERE any(g IN split(rec.Genres, '|') WHERE g IN topGenres)
      AND NOT EXISTS {{
        MATCH (u)-[:RATED]->(rec)
      }}

    RETURN DISTINCT rec.Title AS Films_recommander, rec.Genres AS Genres_recommander
    ORDER BY rec.Title
    LIMIT {top_recommendations}
    """
    try:
        result = gds.run_cypher(query, params={"id": user_id})
        return result
    except Exception as e:
        print(f"Erreur pendant la recommandation : {e}")
        return pd.DataFrame()

recommendations = recommend_by_genre(user_id=75)
print(recommendations)